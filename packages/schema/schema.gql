#
# Copyright (c) Microsoft. All rights reserved.
# Licensed under the MIT license. See LICENSE file in the project.
#
scalar Long

#
# An auth directive for protecting data within an organization.
#
# Required arguments on decorated schema item: 'orgId'
#
directive @orgAuth(requires: RoleType = USER) on OBJECT | FIELD_DEFINITION
directive @auth on OBJECT | FIELD_DEFINITION

# TODO: most of these queries shold be updated to @orgAuth
# TODO: queries should have a single input params variable
type Query {
	#
	# Retrieve a list of organizations
	#
	organizations(body: OrganizationsInput!): [Organization!]! @auth

	#
	# Retrieve an organization by ID
	#
	organization(body: OrganizationIdInput!): Organization @auth

	#
	# Retrieve a User by ID
	#
	user(body: UserIdInput!): User @auth

	#
	# Retrieve a contact by ID
	#
	contact(body: ContactIdInput!): Contact @auth

	#
	# Retrieve a list of contacts
	#
	contacts(body: ContactsInput!): [Contact!]! @auth

	#
	# Retrieve a single engagement by ID
	#
	engagement(body: EngagementIdInput!): Engagement @auth

	#
	# Retrieve a list of active engagements
	#
	activeEngagements(body: EngagementsInput!): [Engagement] @auth

	#
	# Retrieve a list of inactive engagements (i.e. Closed, Completed)
	#
	inactiveEngagements(body: EngagementsInput!): [Engagement] @auth

	#
	# Retrieve a list of engagements
	#
	exportData(body: OrganizationIdInput!): [Engagement] @auth
}

type Mutation {
	#
	# Authenticate a user
	#
	authenticate(body: AuthenticationInput!): AuthenticationResponse!

	#
	# Assign an Engagement
	#
	assignEngagement(body: AssignEngagementInput!): EngagementResponse @auth

	#
	# Create Engagement
	#
	createEngagement(body: EngagementInput!): EngagementResponse @auth

	#
	# Update Engagement
	#
	updateEngagement(body: EngagementInput!): EngagementResponse @auth

	#
	# Set engagement status
	#
	completeEngagement(body: EngagementIdInput!): EngagementResponse @auth

	#
	# Set engagement status
	#
	setEngagementStatus(body: EngagementStatusInput!): EngagementResponse @auth

	#
	# Reset user password
	#
	resetUserPassword(body: UserIdInput!): UserActionResponse @auth

	#
	# Allow user to set password
	#
	setUserPassword(oldPassword: String!, newPassword: String!): UserActionResponse @auth

	#
	# Set engagement status
	#
	addEngagementAction(id: String!, action: ActionInput!): EngagementResponse @auth

	#
	# Create a new user
	#
	createNewUser(user: UserInput!): UserResponse @auth

	#
	# Update user details
	#
	updateUser(user: UserInput!): UserResponse @auth

	markMentionSeen(userId: String!, engagementId: String!): UserResponse @auth

	#
	# Create new organization tag
	#
	createNewTag(orgId: String, tag: TagInput!): TagResponse @auth

	#
	# Update organization tag
	#
	updateTag(orgId: String, tag: TagInput!): TagResponse @auth

	#
	# Create a new contact
	#
	createContact(contact: ContactInput!): ContactResponse @auth

	#
	# Update existing contact details
	#
	updateContact(contact: ContactInput!): ContactResponse @auth

	#
	# Create new organization client attribute
	#
	createAttribute(attribute: AttributeInput!): AttributeResponse @auth

	#
	# Update organization client attribute
	#
	updateAttribute(attribute: AttributeInput!): AttributeResponse @auth
}

type Subscription {
	#
	# Subscribe to user notificaitons
	#
	subscribeToMentions(userId: String!): MentionSubscriptionResponse

	#
	# Subscribe to engagement updates
	#
	engagementUpdate(orgId: String!): EngagementResponse
}

#
# Mention Subscription Response
#
type MentionSubscriptionResponse {
	#
	# The user that has been authenticated; possibly null
	#
	mention: Mention

	#
	# If returned from an update the update may include the type of update (CREATE)
	#
	action: String

	#
	# An error or status message regarding the authentication attempt
	#
	message: String!

	#
	# Status code response
	#
	statusCode: Int
}

enum StatusType {
	SUCCESS
	FAILED
}

#
# General response type for user related actions
#
type UserActionResponse {
	#
	# The user that has been authenticated; possibly null
	#
	user: User

	#
	# An error or status message regarding the authentication attempt
	#
	message: String!

	#
	# Response status
	#
	status: StatusType!
}

#
# An Engagement Response
#
type EngagementResponse {
	#
	# The user that has been authenticated; possibly null
	#
	engagement: Engagement

	#
	# If returned from an update the update may include the type of update (CREATE, UPDATE, DELETE)
	#
	action: String

	#
	# An error or status message regarding the authentication attempt
	#
	message: String!

	#
	# Response status
	#
	status: StatusType!
}

#
# An Authentication Response
#
type AuthenticationResponse {
	#
	# The user that has been authenticated; possibly null
	#
	user: User

	#
	# An error or status message regarding the authentication attempt
	#
	message: String

	#
	# The user access token
	#
	accessToken: String

	#
	# Response status
	#
	status: StatusType!
}

#
# A Community-Based Organization
#
type Organization {
	#
	# A unique identifier for the organization
	#
	id: String!

	#
	# The organization Name
	#
	name: String!

	#
	# A brief description of the organization and its mission
	#
	description: String!

	#
	# Users working with the organization
	#
	# users: [User!]! @orgAuth(requires: USER)
	users: [User!]!

	#
	# Contact working with the organization
	#
	# contacts: [Contact!]! @orgAuth(requires: USER)
	contacts: [Contact!]!

	#
	# Tags available to the organization
	#
	tags: [Tag]

	#
	# Client Attributes available to the organization
	#
	attributes: [Attribute]
}

#
# A label to group engagements and actions
#
type Tag {
	#
	# A unique id for the tag
	#
	id: String!

	#
	# An object containing translated labels for the tag
	#
	label: String!

	#
	# An object containing description for the tag
	#
	description: String

	#
	# An object containing usage counts for the Tag
	#
	usageCount: TagUsageCount
}

type TagUsageCount {
	engagement: Int
	actions: Int
}

#
# Create engagement input
#
input EngagementInput {
	#
	# ID of the engagement request
	#
	engagementId: String
	#
	# ID of the org containing the engagement
	#
	orgId: String!

	#
	# ID of the contact who the engagement is being made for
	#
	contactId: String!

	#
	# Description of engagement request
	#
	description: String!

	#
	# Scheduled duration of the request
	#
	duration: String

	#
	# Optional id of assigned specialist to the engagement
	#
	userId: String

	#
	# Optional tags on the engagement
	#
	tags: [String!]
}

#
# A label to group engagements and actions
#
input TagInput {
	#
	# A unique id for the tag
	#
	id: String

	#
	# An object containing translated labels for the tag
	#
	label: String

	#
	# An object containing description for the tag
	#
	description: String
}

type TagResponse {
	tag: Tag
	message: String
	#
	# Response status
	#
	status: StatusType!
}

#
# An object that contains translations of a string
#
# type TranslateString {
#	en_us: String
#	ko_kr: String
#	vi_vn: String
#	zh_cn: String
#	es_us: String
#	de_de: String
#	es_es: String
#	fi_fi: String
#	fr_fr: String
#	he_il: String
#	it_it: String
#	ja_jp: String
#	pt_pt: String
#	sv_se: String
#	th_th: String
# }

#
# A specialist who can provide services for clients of a CBO
#
type User {
	oid: ID
	#
	# A unique identifier for the specialist
	#
	id: String!

	#
	# A name for a person
	#
	name: Name!

	#
	# A user name for a person
	#
	userName: String!

	#
	# The roles this user has in the system
	#
	roles: [Role!]!

	#
	# The description of this user has in the system
	#
	description: String

	#
	# Additional information this user has in the system
	#
	additionalInfo: String

	#
	# The address of this user has in the system
	#
	address: Address

	#
	# The user email
	#
	email: String

	#
	# The user phone
	#
	phone: String

	#
	# Number of engagements for user, null if not available
	#
	engagementCounts: EngagementCounts

	#
	# Mentions of this user in engagments
	#

	mentions: [Mention!]
}

#
# Basic class to model @mentions
#

type Mention {
	engagementId: String!
	createdAt: String!
	# TODO: add these fields to mentions
	# user: User!
	# message: String
	# type: 'ASSIGNED' | 'TAGGED'
	seen: Boolean!
}

type EngagementCounts {
	active: Int
	closed: Int
}

input UserInput {
	#
	# ID field for the user, incase this is for udpating existing user
	#
	id: String

	#
	# The first name for a person
	#
	first: String!

	#
	# The middle name for a person
	#
	middle: String

	#
	# The last name for a person
	#
	last: String!

	#
	# The username for a person
	#
	userName: String!

	#
	# The roles this user has in the system
	#
	roles: [RoleTypeInput!]

	#
	# The user email
	#
	email: String!

	#
	# The user phone
	#
	phone: String

	#
	# The user address
	#
	address: AddressInput

	#
	# The user basic description / bio
	#
	description: String

	#
	# The user additional info / trainings / achievements
	#
	additionalInfo: String
}

input AddressInput {
	#
	# Street address
	#
	street: String

	#
	# Street address line 2
	#
	unit: String

	#
	# City
	#
	city: String

	#
	# State
	#
	state: String

	#
	# Zip code
	#
	zip: String
}

input RoleTypeInput {
	roleType: RoleType!
	orgId: String!
}

type UserResponse {
	user: User
	message: String
	#
	# Response status
	#
	status: StatusType!
}

type Role {
	#
	# The kind of role the user has
	#
	roleType: RoleType!

	#
	# The organization the role relates to
	#
	orgId: String!
}

enum RoleType {
	USER
	ADMIN
	VIEWER
}

type Address {
	#
	# Street address
	#
	street: String!

	#
	# Street address line 2
	#
	unit: String

	#
	# City
	#
	city: String

	#
	# State
	#
	state: String

	#
	# The organization the role relates to
	#
	zip: String!
}

#
# A person coming into the system who is in need of assistance or resources
#
type Contact {
	#
	# A unique identifier for a contact
	#
	id: String!

	#
	# The contact name
	#
	name: Name!

	#
	# The contact email
	#
	email: String

	#
	# The contact phone
	#
	phone: String

	#
	# The contact address
	#
	address: Address

	#
	# The date of birth
	#
	dateOfBirth: String

	#
	# Engagements this contact has made with Orgs
	#
	engagements(orgId: String): [Engagement!]!

	attributes: [Attribute]
}

input ContactInput {
	#
	# A unique identifier for a contact
	#
	id: String

	#
	# A unique identifier for the organization where a contact belongs
	#
	orgId: String!

	#
	# The first name for a person
	#
	first: String!

	#
	# The middle name for a person
	#
	middle: String

	#
	# The last name for a person
	#
	last: String!

	#
	# The date of birth
	#
	dateOfBirth: String

	#
	# The contact email
	#
	email: String

	#
	# The contact phone
	#
	phone: String

	#
	# The contact address
	#
	address: AddressInput

	#
	# the contact attributes
	#
	attributes: [String!]
}

type ContactResponse {
	contact: Contact
	message: String
	#
	# Response status
	#
	status: StatusType!
}

#
# Engagement Status
#
enum EngagementStatus {
	NOT_STARTED
	OPEN
	CLOSED
	PENDING
	ASSIGNED
	IN_PROGRESS
	COMPLETED
}

#
# A contact's engagement with a CBO
#
type Engagement {
	#
	# ID of the engagement
	#
	id: String!

	#
	# The ID of the organization being engaged
	#
	orgId: String!

	#
	# The assigned specialist. Undefined if not the engagement is not assigned
	#
	user: User

	#
	# The start date of the engagement
	#
	startDate: String!

	#
	# The end date of the engagement
	#
	endDate: String

	#
	# Engagement Actions
	#
	actions: [Action!]!

	#
	# Engagement Status
	#
	status: EngagementStatus!

	#
	# Engagement Contact
	#
	contact: Contact!

	#
	# Engagement Description
	#
	description: String

	#
	# Tags applied to the engagement
	#
	tags: [Tag]
}

#
# Input for adding an action
#
input ActionInput {
	#
	# The id of the user engaging the contact
	#
	userId: String!

	#
	# The id of the organization engaging the contact
	#
	orgId: String!

	#
	# A comment entered by the specialist
	#
	comment: String!

	#
	# Tagged user to be notified of action
	#
	taggedUserId: String

	#
	# Tags applied to the action
	#
	tags: [String]
}

type Action {
	user: User!

	#
	# The id of the organization engaging the contact
	#
	orgId: String!

	#
	# The date the action was taken
	#
	date: String!

	#
	# A comment entered by the specialist
	#
	comment: String!

	#
	# Tagged user to be notified of action
	#
	taggedUser: User

	#
	# Tags applied to the action
	#
	tags: [Tag]
}

#
# A name for a person
#
type Name {
	#
	# A person's first name
	#
	first: String!
	#
	# A person's last name
	#
	last: String!
	#
	# A person's middle name
	#
	middle: String
}

type Attribute {
	#
	# A Client Attribute Id
	#
	id: String!

	#
	# A Client Attribute label
	#
	label: String!

	#
	# A Client Attribute description
	#
	description: String
}

input AttributeInput {
	#
	#  Org Id the attribute will be added to
	#
	orgId: String!

	#
	# A unique id for the tag
	#
	id: String

	#
	# An object containing translated labels for the tag
	#
	label: String!

	#
	# An object containing description for the tag
	#
	description: String
}

type AttributeResponse {
	attribute: Attribute
	message: String
	#
	# Response status
	#
	status: StatusType!
}

input OrganizationsInput {
	offset: Int
	limit: Int
}

input OrganizationIdInput {
	orgId: String!
}

input UserIdInput {
	userId: String!
}

input ContactIdInput {
	contactId: String!
}

input ContactsInput {
	orgId: String!
	offset: Int
	limit: Int
}

input EngagementIdInput {
	engId: String!
}

input EngagementsInput {
	orgId: String!
	offset: Int
	limit: Int
	userId: String
	exclude_userId: Boolean
}

input AuthenticationInput {
	username: String!
	password: String!
}

input AssignEngagementInput {
	engId: String!
	userId: String!
}

input EngagementStatusInput {
	engId: String!
	status: EngagementStatus!
}
